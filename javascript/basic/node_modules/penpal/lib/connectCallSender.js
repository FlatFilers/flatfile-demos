"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("./constants");
const errorCodes_1 = require("./errorCodes");
const generateId_1 = __importDefault(require("./generateId"));
const errorSerialization_1 = require("./errorSerialization");
/**
 * Augments an object with methods that match those defined by the remote. When these methods are
 * called, a "call" message will be sent to the remote, the remote's corresponding method will be
 * executed, and the method's return value will be returned via a message.
 * @param {Object} callSender Sender object that should be augmented with methods.
 * @param {Object} info Information about the local and remote windows.
 * @param {Array} methodNames Names of methods available to be called on the remote.
 * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal
 * connection.
 * @returns {Object} The call sender object with methods that may be called.
 */
exports.default = (callSender, info, methodNames, destroyConnection, log) => {
    const { localName, local, remote, originForSending, originForReceiving } = info;
    let destroyed = false;
    log(`${localName}: Connecting call sender`);
    const createMethodProxy = methodName => {
        return (...args) => {
            log(`${localName}: Sending ${methodName}() call`);
            // This handles the case where the iframe has been removed from the DOM
            // (and therefore its window closed), the consumer has not yet
            // called destroy(), and the user calls a method exposed by
            // the remote. We detect the iframe has been removed and force
            // a destroy() immediately so that the consumer sees the error saying
            // the connection has been destroyed. We wrap this check in a try catch
            // because Edge throws an "Object expected" error when accessing
            // contentWindow.closed on a contentWindow from an iframe that's been
            // removed from the DOM.
            let iframeRemoved;
            try {
                if (remote.closed) {
                    iframeRemoved = true;
                }
            }
            catch (e) {
                iframeRemoved = true;
            }
            if (iframeRemoved) {
                destroyConnection();
            }
            if (destroyed) {
                const error = new Error(`Unable to send ${methodName}() call due ` + `to destroyed connection`);
                error.code = errorCodes_1.ERR_CONNECTION_DESTROYED;
                throw error;
            }
            return new Promise((resolve, reject) => {
                const id = generateId_1.default();
                const handleMessageEvent = event => {
                    if (event.source !== remote ||
                        event.data.penpal !== constants_1.REPLY ||
                        event.data.id !== id) {
                        return;
                    }
                    if (event.origin !== originForReceiving) {
                        log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);
                        return;
                    }
                    log(`${localName}: Received ${methodName}() reply`);
                    local.removeEventListener(constants_1.MESSAGE, handleMessageEvent);
                    let returnValue = event.data.returnValue;
                    if (event.data.returnValueIsError) {
                        returnValue = errorSerialization_1.deserializeError(returnValue);
                    }
                    (event.data.resolution === constants_1.FULFILLED ? resolve : reject)(returnValue);
                };
                local.addEventListener(constants_1.MESSAGE, handleMessageEvent);
                remote.postMessage({
                    penpal: constants_1.CALL,
                    id,
                    methodName,
                    args
                }, originForSending);
            });
        };
    };
    methodNames.reduce((api, methodName) => {
        api[methodName] = createMethodProxy(methodName);
        return api;
    }, callSender);
    return () => {
        destroyed = true;
    };
};
