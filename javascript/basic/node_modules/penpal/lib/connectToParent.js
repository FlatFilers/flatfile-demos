"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("./constants");
const errorCodes_1 = require("./errorCodes");
const createDestructor_1 = __importDefault(require("./createDestructor"));
const connectCallReceiver_1 = __importDefault(require("./connectCallReceiver"));
const connectCallSender_1 = __importDefault(require("./connectCallSender"));
const createLogger_1 = __importDefault(require("./createLogger"));
/**
 * @typedef {Object} Parent
 * @property {Promise} promise A promise which will be resolved once a connection has
 * been established.
 * @property {Function} destroy A method that, when called, will disconnect any
 * messaging channels. You may call this even before a connection has been established.
 */
/**
 * Attempts to establish communication with the parent window.
 * @param {Object} options
 * @param {string} [options.parentOrigin=*] Valid parent origin used to restrict communication.
 * @param {Object} [options.methods={}] Methods that may be called by the parent window.
 * @param {Number} [options.timeout] The amount of time, in milliseconds, Penpal should wait
 * for the parent to respond before rejecting the connection promise.
 * @return {Parent}
 */
exports.default = ({ parentOrigin = '*', methods = {}, timeout, debug } = {}) => {
    const log = createLogger_1.default(debug);
    if (window === window.top) {
        const error = new Error('connectToParent() must be called within an iframe');
        error.code = errorCodes_1.ERR_NOT_IN_IFRAME;
        throw error;
    }
    const { destroy, onDestroy } = createDestructor_1.default();
    const child = window;
    const parent = child.parent;
    const promise = new Promise((resolveConnectionPromise, reject) => {
        let connectionTimeoutId;
        if (timeout !== undefined) {
            connectionTimeoutId = setTimeout(() => {
                const error = new Error(`Connection to parent timed out after ${timeout}ms`);
                error.code = errorCodes_1.ERR_CONNECTION_TIMEOUT;
                reject(error);
                destroy();
            }, timeout);
        }
        const handleMessageEvent = event => {
            // Under niche scenarios, we get into this function after
            // the iframe has been removed from the DOM. In Edge, this
            // results in "Object expected" errors being thrown when we
            // try to access properties on window (global properties).
            // For this reason, we try to access a global up front (clearTimeout)
            // and if it fails we can assume the iframe has been removed
            // and we ignore the message event.
            try {
                clearTimeout();
            }
            catch (e) {
                return;
            }
            if (event.source !== parent || event.data.penpal !== constants_1.HANDSHAKE_REPLY) {
                return;
            }
            if (parentOrigin !== '*' && parentOrigin !== event.origin) {
                log(`Child received handshake reply from origin ${event.origin} which did not match expected origin ${parentOrigin}`);
                return;
            }
            log('Child: Received handshake reply');
            child.removeEventListener(constants_1.MESSAGE, handleMessageEvent);
            const info = {
                localName: 'Child',
                local: child,
                remote: parent,
                originForSending: event.origin === 'null' ? '*' : event.origin,
                originForReceiving: event.origin
            };
            const callSender = {};
            const destroyCallReceiver = connectCallReceiver_1.default(info, methods, log);
            onDestroy(destroyCallReceiver);
            const destroyCallSender = connectCallSender_1.default(callSender, info, event.data.methodNames, destroy, log);
            onDestroy(destroyCallSender);
            clearTimeout(connectionTimeoutId);
            resolveConnectionPromise(callSender);
        };
        child.addEventListener(constants_1.MESSAGE, handleMessageEvent);
        onDestroy(() => {
            child.removeEventListener(constants_1.MESSAGE, handleMessageEvent);
            const error = new Error('Connection destroyed');
            error.code = errorCodes_1.ERR_CONNECTION_DESTROYED;
            reject(error);
        });
        log('Child: Sending handshake');
        parent.postMessage({
            penpal: constants_1.HANDSHAKE,
            methodNames: Object.keys(methods)
        }, parentOrigin);
    });
    return {
        promise,
        destroy
    };
};
